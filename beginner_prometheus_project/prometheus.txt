Látogasunk el a https://prometheus.io/ oldalra -> kattints a download-ra ->
Ha nem talalod a megfelelöt akkor kattints a Release notes-ra és átirányít a github oldalra ->
Linux szervernek töltom le ugyhogy...

# Legújabb verzió letöltése
  cd /
  cd /opt
  sudo wget https://github.com/prometheus/prometheus/releases/download/v3.3.1/prometheus-3.3.1.linux-amd64.tar.gz
  ls

# Csomag kicsomagolása
  sudo tar xvf prometheus-3.3.1.linux-amd64.tar.gz
  ls
  cd prometheus-3.3.1.linux-amd64/

# Fájlok áthelyezése
  sudo mv prometheus /usr/local/bin/
  sudo mv promtool /usr/local/bin/
  sudo mkdir -p /etc/prometheus
  sudo mv prometheus.yml /etc/prometheus/
  sudo mkdir -p /var/lib/prometheus
  sudo cp -r consoles/ console_libraries/ /etc/prometheus/

# Systemd szolgáltatás létrehozása
  sudo nano /etc/systemd/system/prometheus.service

Tartalma:

[Unit]
Description=Prometheus
Wants=network-online.target
After=network-online.target

[Service]
User=nobody
ExecStart=/usr/local/bin/prometheus \
  --config.file=/etc/prometheus/prometheus.yml \
  --storage.tsdb.path=/var/lib/prometheus/ \
  --web.console.templates=/etc/prometheus/consoles \
  --web.console.libraries=/etc/prometheus/console_libraries

[Install]
WantedBy=default.target

# Szolgáltatás engedélyezése és indítása
  sudo systemctl daemon-reexec
  sudo systemctl enable prometheus
  sudo systemctl start prometheus

# Webes elérés (Ha minden jól ment)
http://<szerver_ip>:9090

# Cím használata: localhost:9090 vs <szerver_ip>:9090
A localhost:9090 azt jelenti, hogy a Prometheus önmagát monitorozza.
Ha másik gépről akarsz hozzáférni a web UI-hez (pl. a böngészőből), akkor a szerver IP címét kell megadni, például: http://192.168.1.123:9090
A prometheus.yml fájlban maradhat localhost:9090, mert az ottani cél az, hogy saját magát lekérdezze belsőleg.

# Ha nem működik akkor a megoldás
  sudo chown -R nobody:nogroup /var/lib/prometheus	# Állítsd be a megfelelő tulajdonost (ha nobody-val fut a szolgáltatás). (Ha mást használsz a prometheus.service fájlban pl. prometheus, akkor azt add meg helyette.)
  sudo systemctl restart prometheus			# Indítsd újra a szolgáltatást:
  sudo systemctl status prometheus			# Nézd meg az állapotot:

# YAML fajl konfiguralasa
 sudo nano /etc/prometheus/prometheus.yml

global:
  scrape_interval: 5s

scrape_configs:
- job_name: "prometheus"
  static_configs:
  - targets:
    - localhost:9090
- job_name: "demo"
  static_configs:
  - targets:
    - demo.promlabs.com:10000
    - demo.promlabs.com:10001
    - demo.promlabs.com:10002

Mit jelent?
global.scrape_interval: 5s	->  minden targetet 5 másodpercenként lekérdez.
job_name: "prometheus"		->  ez saját magára hivatkozik (lokálisan gyűjt adatot).
job_name: "demo"		->  külső mintaadatokat gyűjt egy demo oldalról (játékos célra nagyon jó)

# Indítás parancssorból
A systemd telepítés után nem kell már ezt csinálni:
cd /usr/local/bin/prometheus
./prometheus

Mert most már így kell:
sudo systemctl restart prometheus

# Böngészőből elérni Prometheust
Látogass el erre:
http://<szerver_ip>:9090

Majd:
Menü: Status -> Targets -> itt láthatod az aktív scrape célokat (mint localhost:9090, demo.promlabs.com:10000, stb.)

# Lekérdezések a főoldalon
A keresőmezőbe beírhatod:
Alapmetrika:
prometheus_tsdb_head_samples_appended_total
Ez mutatja, mennyi minta lett rögzítve.

Rate függvény:
rate(prometheus_tsdb_head_samples_appended_total[1m])

Ez azt mutatja, milyen sebességgel érkeznek a minták (per másodperc, 1 perces ablak alapján).

Histogram példa:
histogram_quantile(0.9, sum by(le, path) (rate(demo_api_request_duration_seconds_bucket[5m])))

Ez a demo endpoint válaszidejének 90%-os értékét mutatja (tehát az API-hívások 90%-a ennyi idő alatt vagy gyorsabban lefutott).

# Összefoglalás: mit tegyél most
Hagyd localhost:9090-on a saját lekérdezést.
Böngészőből a szerver IP címével nyisd meg Prometheust.
Ne futtasd a binárist kézzel (./prometheus), csak systemctl restart prometheus.
Lekérdezések mennek a UI-ból,rate(...), histogram_quantile(...).

# Prometheus Metrikatípusok Összefoglaló
1. Gauges – Változó értékek mérése
A gauge típusú metrikák értéke felfelé és lefelé is változhat. Tipikus példák:

gueueLength.Set(0)       // konkrét érték beállítása
gueueLength.Inc()        // növelés 1-gyel
gueueLength.Dec()        // csökkentés 1-gyel
gueueLength.Add(23)      // növelés 23-mal
gueueLength.Sub(42)      // csökkentés 42-vel

Használat: például várakozási sor hossza, memóriahasználat, hőmérséklet stb.

2. Counters – Csak növekvő értékek mérése
A counter típus mindig csak növekszik – például egy esemény előfordulásának számát méri. Sosem csökken vissza.

totalRequests.Inc()       // 1-gyel növelés
totalRequests.Add(5)      // 5-tel növelés

Prometheus-beli példa:
http_request_total 7734
rate(http_request_total[5m])         // időegységre vetített átlagos növekedési ráta
irate(http_request_total[1m])        // azonnali növekedési sebesség
increase(http_request_total[1h])     // adott időintervallum alatti teljes növekedés

Használat: pl. HTTP kérések száma, hibák száma stb.

3. Summaries – Eloszlás és percentilisek
A summary metrika olyan numerikus értékek eloszlását méri, mint például a válaszidő. Ezekből automatikusan percentiliseket számít (pl. 95%, 99%).

requestDurations.Observe(2.3)   // egy új mérési adat rögzítése

Használat: pl. API válaszidők, feldolgozási idő stb.
Megjegyzés: A kvantilisek (percentilisek) lokálisan kerülnek kiszámításra, és aggregálásuk korlátozott.

4. Histograms – Eloszlás kategóriák szerint
A histogram metrika az értékeket előre definiált intervallumokba (bucketekbe) sorolja. Ez lehetővé teszi az eloszlás kategóriák szerinti elemzését.

Prometheus metrika példa:

http_request_duration_seconds_bucket{le="0.05"} 4599

Ez azt jelzi, hogy 4599 kérés volt, amelynek időtartama ≤ 0.05 másodperc.

Kvantilis számítás hisztogramból:

histogram_quantile(
  0.9,  // 90%-os kvantilis
  sum by(path, method, le) (
    rate(http_request_duration_seconds_bucket[5m])
  )
)

Használat: válaszidő, feldolgozási idő eloszlása aggregálható módon (ellentétben a summary-vel).

Összegzés
Típus		Leírás					Növekedés / Csökkenés	Percentilis / Kvantilis		Aggregálhatóság
Gauge		Állapotmetrika (bármerre változhat)	✅	  / ✅		❌				✅
Counter		Eseményszámláló (csak növekszik)	✅	  / ❌		❌				✅
Summary		Percentilisek kiszámítása lokálisan	✅	  / ❌		✅				❌ (nem aggregálható)
Histogram	Értékek intervallumokban		✅	  / ❌		✅ (histogram_quantile)		✅

# PromQL Adatkiválasztás – Instant és Range Vectorok, Offsetek, Időbélyegek
A PromQL lekérdezésekben különböző típusú vektorokat használunk attól függően, milyen adatokat szeretnénk kinyerni.

1. Instant Vector Selector – Egy adott időpontra vonatkozó értékek
Ez a leggyakoribb forma: egy adott időpillanatban mért értékeket kérdez le.
demo_memory_usage_bytes

Szűrés címkék alapján:
demo_memory_usage_bytes{type=~"buffers|cached"}			       // buffers vagy cached típus
demo_memory_usage_bytes{type!~"buffers|cached"}			       // nem buffers és nem cached
demo_memory_usage_bytes{type!~".*uff.*"}			       // nem tartalmazza az "uff" szót
demo_memory_usage_bytes{type!="free",instance="demo-service-0:10000"}  // összetett feltétel

# 2. Range Vector Selector – Időintervallumra vonatkozó értékek
A range vector az értékek sorozatát adja vissza egy adott időintervallumban.

demo_cpu_usage_seconds_total[1m]   // Hiba: önmagában range vector nem lekérdezhető (aggregáció vagy függvény szükséges)

! Fontos: A range vector típus nem adható vissza önmagában, csak egy függvénnyel együtt.

Példa helyes használatra:

rate(demo_cpu_usage_seconds_total[1m])   // 1 perces időszak alatti növekedési ráta

3. Offset használata – Relatív időeltolás
Az offset kulcsszó segítségével egy metrika korábbi állapotát kérdezhetjük le.

demo_memory_usage_bytes offset 2m   // az érték lekérdezése 2 perccel ezelőtti állapotra

4. Absolute timestamps (időbélyeg alapú lekérdezés)
Az @ szintaxis egy adott időbélyegre (Unix timestamp) vagy időhatárra hivatkozik.

demo_memory_usage_bytes @ 1684694074        // konkrét időbélyeg
demo_memory_usage_bytes @ start()           // a lekérdezési időintervallum eleje
demo_memory_usage_bytes @ end()             // a lekérdezési időintervallum vége

5. Kombinációk – Offset + Timestamps + Range
Lehetőség van ezek kombinálására is:

demo_memory_usage_bytes{instance="demo.promlabs.com:10000"}[1m] offset 1h @ 1684694074

Ez a lekérdezés azt kéri le, hogy 1 perces időablakban, az 1 órával korábbi állapotból, milyen értékek voltak a 1684694074-es időbélyegen.

6. Staleness Handling – "Elöregedett" metrikák kezelése
A Prometheus automatikusan felismeri a "stale" (elavult) időpontokat, ha egy metrika már nem frissül. Ilyenkor nem jelenik meg érték, vagy NaN-t (not a number) ad vissza.
Ez akkor fontos, ha például egy szolgáltatás megszűnt adatot küldeni – a Prometheus 5 percen belül automatikusan eltávolítja az aktív metrikák közül.

# Összegzés – Gyakori fogalmak:
Fogalom			Leírás
Instant Vector		Egy pillanatban vett minták
Range Vector		Minták sorozata időablakban
Offset			Relatív időeltolás (pl. 1h-val korábban)
@ timestamp		Abszolút időpont (Unix timestamp alapján)
Staleness		Automatikus adat-öregedés kezelése
rate(), irate()		Változások mértéke idő szerint
start(), end()		Lekérdezési ablak eleje/vége

# 1. Mi az a counter típus?
Egy counter mindig csak növekszik (pl. kérések száma, hibák száma).
Soha nem csökken – kivéve, ha a szolgáltatás újraindul (és akkor visszaugrik 0-ra).
Példa metrika:

demo_api_request_duration_seconds_count{status="200"}

Ez azt mutatja, hány HTTP 200 sikeres válasz történt összesen az indulás óta.

# 2. Mit csinál az increase()?
increase(<counter_metric>[időablak])
Ez azt mutatja meg, hogy mekkora volt a növekedés a kiválasztott időszakban.
Példa:

increase(demo_api_request_duration_seconds_count{status="200"}[5m])

Azt mutatja: az elmúlt 5 percben hány sikeres API kérés volt (status=200).
Ha 5 perccel ezelőtt 1000 volt, most pedig 1200 -> increase = 200
Ha újraindult a szerver, és nulláról indult újra -> Prometheus ezt felismeri, és nem von le tévesen nagy értékeket

# 3. Mit csinál a rate()?
rate(<counter_metric>[időablak])
Ez sebességet számol – érték / másodperc.
Példa:

rate(demo_api_request_duration_seconds_count{status="200"}[5m])

Ez azt mutatja: átlagosan másodpercenként hány sikeres kérés történt az elmúlt 5 percben
Előny: Szép, simított grafikonokhoz használják
Hátrány: nehéz pontosan értelmezni (pl. 1.2 -> másodpercenként 1.2 kérés átlagosan)

# 4. Mikor melyiket használd?

Cél							Használd ezt
Összes esemény egy időszakon belül			increase(...)
Átlagos sebesség / másodperc				rate(...)
Grafikonhoz, trendhez					rate(...)
Pontos értékekhez (pl. 5 perc alatt mennyi történt)	increase(...)

5. Mi van, ha újraindul a szolgáltatás?
A counter visszaugrik nullára, de:
rate() és increase() automatikusan korrigálnak
Ha egy 500-as érték hirtelen 0-ra vált, azt nem tekinti csökkenésnek
Ezért fontos, hogy a metrika típusa tényleg counter legyen, különben félreérti

# 6. Mit jelent ez a példa?

increase(demo_api_request_duration_seconds_count{status="200"}[5m])

Az elmúlt 5 percben hány sikeres API válasz történt (HTTP 200-as).
Gyakorlati haszna:
  Grafikonon láthatod a terhelést időben
  Riasztást állíthatsz be: „ha 5 perc alatt 0 kérés érkezett, akkor baj van”

# 1. up{...} – Az életjel-metrika
Átírjuk a yaml fájlt
sudo nano /etc/prometheus/prometheus.yml

global:
  scrape_interval: 5s

scrape_configs:
  - job_name: prometheus
    static_configs:
      - targets:
        - localhost:9090
  - job_name: test-job
    static_configs:
      - targets:
        - localhost:8080

Ez a legfontosabb automatikus (synthetic) metrika, amit a Prometheus minden céltól gyűjt. Azt mutatja meg:

Érték	Jelentés
1	A cél elérhető, válaszolt
0	A cél nem érhető el, vagy hiba történt	

Példa:

up{job="test-job"}

Ha = 0, az azt jelenti: nem fut semmi a localhost:8080 címen.

# 2. scrape_duration_seconds
Ez megmutatja, hogy mennyi ideig tartott a lekérés az adott céltól.
Ha a cél elérhetetlen, általában nagyon kicsi szám, vagy 0, mert gyorsan visszajön a hiba.

# 3. scrape_samples_scraped
Ennyi mintát/metrikát sikerült “lekaparni” (scrape) az adott szolgáltatástól.
Ha a cél nem ad vissza semmit (pl. nem fut semmi), akkor:

scrape_samples_scraped = 0

# 4. scrape_samples_post_metric_relabeling
Ez azt mutatja meg, hogy a metrika relabeling szabályok (ha vannak) után mennyi minta maradt.
Ha nincs relabeling, ez megegyezik az előző értékkel (vagy nulla, ha nem volt válasz).

# 5. scrape_series_added
Ez az érték azt mutatja, hogy hány új idősort (time series-t) adott hozzá a Prometheus a tárolójához a scrape során.
Ha 0 -> vagy nem volt új adat, vagy nem sikerült elérni a célt.

# Ezek honnan származnak?
Ezek automatikusan generált mutatók, amiket a Prometheus saját maga hoz létre minden célhoz, nem a cél szolgáltatásai küldik vissza!
Ezek alapján tudod ellenőrizni például:
  Melyik szolgáltatás elérhető?
  Melyik mikor omlott le?
  A scrape műveletek gyorsak vagy lassúak?
  Mennyire stabil a monitorozott rendszer?

# Mit tehetsz velük?
Gyakorlati példa:

1. Alert (riasztás) létrehozása:

up == 0

Ha egy cél DOWN, erről tudsz alert-et küldeni e-mailen, Slacken, stb. pl. Alertmanagerrel.

2. Grafikon a scrape időkről:

avg_over_time(scrape_duration_seconds[1m])

Ez megmutatja, ha pl. egy szolgáltatás lassan válaszol – hasznos teljesítménydiagnosztikához.

# 3. Hibás scrape-ek figyelése:

increase(scrape_samples_scraped[5m]) == 0

Ha egy cél 5 percen belül semmit nem adott vissza, az is intő jel.

Összefoglalás – up és barátai
Metrika					Mit mutat
up					A cél elérhető-e (1 vagy 0)
scrape_duration_seconds			Lekérés ideje
scrape_samples_scraped			Hány minta jött
scrape_samples_post_metric_relabeling	Minta relabeling után
scrape_series_added			Hány új sor került be

Ezek mindig jelen vannak minden scrape_configs-ban szereplő target esetén – még akkor is, ha maga a cél nem ad vissza metrikát!

folyt köv....
