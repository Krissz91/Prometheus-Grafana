Látogasunk el a https://prometheus.io/ oldalra -> kattints a download-ra ->
Ha nem talalod a megfelelöt akkor kattints a Release notes-ra és átirányít a github oldalra ->
Linux szervernek töltom le ugyhogy...

# Legújabb verzió letöltése
  cd /
  cd /opt
  sudo wget https://github.com/prometheus/prometheus/releases/download/v3.3.1/prometheus-3.3.1.linux-amd64.tar.gz
  ls

# Csomag kicsomagolása
  sudo tar xvf prometheus-3.3.1.linux-amd64.tar.gz
  ls
  cd prometheus-3.3.1.linux-amd64/

# Fájlok áthelyezése
  sudo mv prometheus /usr/local/bin/
  sudo mv promtool /usr/local/bin/
  sudo mkdir -p /etc/prometheus
  sudo mv prometheus.yml /etc/prometheus/
  sudo mkdir -p /var/lib/prometheus
  sudo cp -r consoles/ console_libraries/ /etc/prometheus/

# Systemd szolgáltatás létrehozása
  sudo nano /etc/systemd/system/prometheus.service

Tartalma:

[Unit]
Description=Prometheus
Wants=network-online.target
After=network-online.target

[Service]
User=nobody
ExecStart=/usr/local/bin/prometheus \
  --config.file=/etc/prometheus/prometheus.yml \
  --storage.tsdb.path=/var/lib/prometheus/ \
  --web.console.templates=/etc/prometheus/consoles \
  --web.console.libraries=/etc/prometheus/console_libraries

[Install]
WantedBy=default.target

# Szolgáltatás engedélyezése és indítása
  sudo systemctl daemon-reexec
  sudo systemctl enable prometheus
  sudo systemctl start prometheus

# Webes elérés (Ha minden jól ment)
http://<szerver_ip>:9090

# Cím használata: localhost:9090 vs <szerver_ip>:9090
A localhost:9090 azt jelenti, hogy a Prometheus önmagát monitorozza.
Ha másik gépről akarsz hozzáférni a web UI-hez (pl. a böngészőből), akkor a szerver IP címét kell megadni, például: http://192.168.1.123:9090
A prometheus.yml fájlban maradhat localhost:9090, mert az ottani cél az, hogy saját magát lekérdezze belsőleg.

# Ha nem működik akkor a megoldás
  sudo chown -R nobody:nogroup /var/lib/prometheus	# Állítsd be a megfelelő tulajdonost (ha nobody-val fut a szolgáltatás). (Ha mást használsz a prometheus.service fájlban pl. prometheus, akkor azt add meg helyette.)
  sudo systemctl restart prometheus			# Indítsd újra a szolgáltatást:
  sudo systemctl status prometheus			# Nézd meg az állapotot:

# YAML fajl konfiguralasa
 sudo nano /etc/prometheus/prometheus.yml

global:
  scrape_interval: 5s

scrape_configs:
- job_name: "prometheus"
  static_configs:
  - targets:
    - localhost:9090
- job_name: "demo"
  static_configs:
  - targets:
    - demo.promlabs.com:10000
    - demo.promlabs.com:10001
    - demo.promlabs.com:10002

Mit jelent?
global.scrape_interval: 5s	->  minden targetet 5 másodpercenként lekérdez.
job_name: "prometheus"		->  ez saját magára hivatkozik (lokálisan gyűjt adatot).
job_name: "demo"		->  külső mintaadatokat gyűjt egy demo oldalról (játékos célra nagyon jó)

# Indítás parancssorból
A systemd telepítés után nem kell már ezt csinálni:
cd /usr/local/bin/prometheus
./prometheus

Mert most már így kell:
sudo systemctl restart prometheus

# Böngészőből elérni Prometheust
Látogass el erre:
http://<szerver_ip>:9090

Majd:
Menü: Status -> Targets -> itt láthatod az aktív scrape célokat (mint localhost:9090, demo.promlabs.com:10000, stb.)

# Lekérdezések a főoldalon
A keresőmezőbe beírhatod:
Alapmetrika:
prometheus_tsdb_head_samples_appended_total
Ez mutatja, mennyi minta lett rögzítve.

Rate függvény:
rate(prometheus_tsdb_head_samples_appended_total[1m])

Ez azt mutatja, milyen sebességgel érkeznek a minták (per másodperc, 1 perces ablak alapján).

Histogram példa:
histogram_quantile(0.9, sum by(le, path) (rate(demo_api_request_duration_seconds_bucket[5m])))

Ez a demo endpoint válaszidejének 90%-os értékét mutatja (tehát az API-hívások 90%-a ennyi idő alatt vagy gyorsabban lefutott).

# Összefoglalás: mit tegyél most
Hagyd localhost:9090-on a saját lekérdezést.
Böngészőből a szerver IP címével nyisd meg Prometheust.
Ne futtasd a binárist kézzel (./prometheus), csak systemctl restart prometheus.
Lekérdezések mennek a UI-ból,rate(...), histogram_quantile(...).

# Prometheus Metrikatípusok Összefoglaló
1. Gauges – Változó értékek mérése
A gauge típusú metrikák értéke felfelé és lefelé is változhat. Tipikus példák:

gueueLength.Set(0)       // konkrét érték beállítása
gueueLength.Inc()        // növelés 1-gyel
gueueLength.Dec()        // csökkentés 1-gyel
gueueLength.Add(23)      // növelés 23-mal
gueueLength.Sub(42)      // csökkentés 42-vel

Használat: például várakozási sor hossza, memóriahasználat, hőmérséklet stb.

2. Counters – Csak növekvő értékek mérése
A counter típus mindig csak növekszik – például egy esemény előfordulásának számát méri. Sosem csökken vissza.

totalRequests.Inc()       // 1-gyel növelés
totalRequests.Add(5)      // 5-tel növelés

Prometheus-beli példa:
http_request_total 7734
rate(http_request_total[5m])         // időegységre vetített átlagos növekedési ráta
irate(http_request_total[1m])        // azonnali növekedési sebesség
increase(http_request_total[1h])     // adott időintervallum alatti teljes növekedés

Használat: pl. HTTP kérések száma, hibák száma stb.

3. Summaries – Eloszlás és percentilisek
A summary metrika olyan numerikus értékek eloszlását méri, mint például a válaszidő. Ezekből automatikusan percentiliseket számít (pl. 95%, 99%).

requestDurations.Observe(2.3)   // egy új mérési adat rögzítése

Használat: pl. API válaszidők, feldolgozási idő stb.
Megjegyzés: A kvantilisek (percentilisek) lokálisan kerülnek kiszámításra, és aggregálásuk korlátozott.

4. Histograms – Eloszlás kategóriák szerint
A histogram metrika az értékeket előre definiált intervallumokba (bucketekbe) sorolja. Ez lehetővé teszi az eloszlás kategóriák szerinti elemzését.

Prometheus metrika példa:

http_request_duration_seconds_bucket{le="0.05"} 4599

Ez azt jelzi, hogy 4599 kérés volt, amelynek időtartama ≤ 0.05 másodperc.

Kvantilis számítás hisztogramból:

histogram_quantile(
  0.9,  // 90%-os kvantilis
  sum by(path, method, le) (
    rate(http_request_duration_seconds_bucket[5m])
  )
)

Használat: válaszidő, feldolgozási idő eloszlása aggregálható módon (ellentétben a summary-vel).

Összegzés
Típus		Leírás					Növekedés / Csökkenés	Percentilis / Kvantilis		Aggregálhatóság
Gauge		Állapotmetrika (bármerre változhat)	✅	  / ✅		❌				✅
Counter		Eseményszámláló (csak növekszik)	✅	  / ❌		❌				✅
Summary		Percentilisek kiszámítása lokálisan	✅	  / ❌		✅				❌ (nem aggregálható)
Histogram	Értékek intervallumokban		✅	  / ❌		✅ (histogram_quantile)		✅

# PromQL Adatkiválasztás – Instant és Range Vectorok, Offsetek, Időbélyegek
A PromQL lekérdezésekben különböző típusú vektorokat használunk attól függően, milyen adatokat szeretnénk kinyerni.

1. Instant Vector Selector – Egy adott időpontra vonatkozó értékek
Ez a leggyakoribb forma: egy adott időpillanatban mért értékeket kérdez le.
demo_memory_usage_bytes

Szűrés címkék alapján:
demo_memory_usage_bytes{type=~"buffers|cached"}			       // buffers vagy cached típus
demo_memory_usage_bytes{type!~"buffers|cached"}			       // nem buffers és nem cached
demo_memory_usage_bytes{type!~".*uff.*"}			       // nem tartalmazza az "uff" szót
demo_memory_usage_bytes{type!="free",instance="demo-service-0:10000"}  // összetett feltétel

# 2. Range Vector Selector – Időintervallumra vonatkozó értékek
A range vector az értékek sorozatát adja vissza egy adott időintervallumban.

demo_cpu_usage_seconds_total[1m]   // Hiba: önmagában range vector nem lekérdezhető (aggregáció vagy függvény szükséges)

! Fontos: A range vector típus nem adható vissza önmagában, csak egy függvénnyel együtt.

Példa helyes használatra:

rate(demo_cpu_usage_seconds_total[1m])   // 1 perces időszak alatti növekedési ráta

3. Offset használata – Relatív időeltolás
Az offset kulcsszó segítségével egy metrika korábbi állapotát kérdezhetjük le.

demo_memory_usage_bytes offset 2m   // az érték lekérdezése 2 perccel ezelőtti állapotra

4. Absolute timestamps (időbélyeg alapú lekérdezés)
Az @ szintaxis egy adott időbélyegre (Unix timestamp) vagy időhatárra hivatkozik.

demo_memory_usage_bytes @ 1684694074        // konkrét időbélyeg
demo_memory_usage_bytes @ start()           // a lekérdezési időintervallum eleje
demo_memory_usage_bytes @ end()             // a lekérdezési időintervallum vége

5. Kombinációk – Offset + Timestamps + Range
Lehetőség van ezek kombinálására is:

demo_memory_usage_bytes{instance="demo.promlabs.com:10000"}[1m] offset 1h @ 1684694074

Ez a lekérdezés azt kéri le, hogy 1 perces időablakban, az 1 órával korábbi állapotból, milyen értékek voltak a 1684694074-es időbélyegen.

6. Staleness Handling – "Elöregedett" metrikák kezelése
A Prometheus automatikusan felismeri a "stale" (elavult) időpontokat, ha egy metrika már nem frissül. Ilyenkor nem jelenik meg érték, vagy NaN-t (not a number) ad vissza.
Ez akkor fontos, ha például egy szolgáltatás megszűnt adatot küldeni – a Prometheus 5 percen belül automatikusan eltávolítja az aktív metrikák közül.

# Összegzés – Gyakori fogalmak:
Fogalom			Leírás
Instant Vector		Egy pillanatban vett minták
Range Vector		Minták sorozata időablakban
Offset			Relatív időeltolás (pl. 1h-val korábban)
@ timestamp		Abszolút időpont (Unix timestamp alapján)
Staleness		Automatikus adat-öregedés kezelése
rate(), irate()		Változások mértéke idő szerint
start(), end()		Lekérdezési ablak eleje/vége

# 1. Mi az a counter típus?
Egy counter mindig csak növekszik (pl. kérések száma, hibák száma).
Soha nem csökken – kivéve, ha a szolgáltatás újraindul (és akkor visszaugrik 0-ra).
Példa metrika:

demo_api_request_duration_seconds_count{status="200"}

Ez azt mutatja, hány HTTP 200 sikeres válasz történt összesen az indulás óta.

# 2. Mit csinál az increase()?
increase(<counter_metric>[időablak])
Ez azt mutatja meg, hogy mekkora volt a növekedés a kiválasztott időszakban.
Példa:

increase(demo_api_request_duration_seconds_count{status="200"}[5m])

Azt mutatja: az elmúlt 5 percben hány sikeres API kérés volt (status=200).
Ha 5 perccel ezelőtt 1000 volt, most pedig 1200 -> increase = 200
Ha újraindult a szerver, és nulláról indult újra -> Prometheus ezt felismeri, és nem von le tévesen nagy értékeket

# 3. Mit csinál a rate()?
rate(<counter_metric>[időablak])
Ez sebességet számol – érték / másodperc.
Példa:

rate(demo_api_request_duration_seconds_count{status="200"}[5m])

Ez azt mutatja: átlagosan másodpercenként hány sikeres kérés történt az elmúlt 5 percben
Előny: Szép, simított grafikonokhoz használják
Hátrány: nehéz pontosan értelmezni (pl. 1.2 -> másodpercenként 1.2 kérés átlagosan)

# 4. Mikor melyiket használd?

Cél							Használd ezt
Összes esemény egy időszakon belül			increase(...)
Átlagos sebesség / másodperc				rate(...)
Grafikonhoz, trendhez					rate(...)
Pontos értékekhez (pl. 5 perc alatt mennyi történt)	increase(...)

5. Mi van, ha újraindul a szolgáltatás?
A counter visszaugrik nullára, de:
rate() és increase() automatikusan korrigálnak
Ha egy 500-as érték hirtelen 0-ra vált, azt nem tekinti csökkenésnek
Ezért fontos, hogy a metrika típusa tényleg counter legyen, különben félreérti

# 6. Mit jelent ez a példa?

increase(demo_api_request_duration_seconds_count{status="200"}[5m])

Az elmúlt 5 percben hány sikeres API válasz történt (HTTP 200-as).
Gyakorlati haszna:
  Grafikonon láthatod a terhelést időben
  Riasztást állíthatsz be: „ha 5 perc alatt 0 kérés érkezett, akkor baj van”

# 1. up{...} – Az életjel-metrika
Átírjuk a yaml fájlt
sudo nano /etc/prometheus/prometheus.yml

global:
  scrape_interval: 5s

scrape_configs:
  - job_name: prometheus
    static_configs:
      - targets:
        - localhost:9090
  - job_name: test-job
    static_configs:
      - targets:
        - localhost:8080

Ez a legfontosabb automatikus (synthetic) metrika, amit a Prometheus minden céltól gyűjt. Azt mutatja meg:

Érték	Jelentés
1	A cél elérhető, válaszolt
0	A cél nem érhető el, vagy hiba történt	

Példa:

up{job="test-job"}

Ha = 0, az azt jelenti: nem fut semmi a localhost:8080 címen.

# 2. scrape_duration_seconds
Ez megmutatja, hogy mennyi ideig tartott a lekérés az adott céltól.
Ha a cél elérhetetlen, általában nagyon kicsi szám, vagy 0, mert gyorsan visszajön a hiba.

# 3. scrape_samples_scraped
Ennyi mintát/metrikát sikerült “lekaparni” (scrape) az adott szolgáltatástól.
Ha a cél nem ad vissza semmit (pl. nem fut semmi), akkor:

scrape_samples_scraped = 0

# 4. scrape_samples_post_metric_relabeling
Ez azt mutatja meg, hogy a metrika relabeling szabályok (ha vannak) után mennyi minta maradt.
Ha nincs relabeling, ez megegyezik az előző értékkel (vagy nulla, ha nem volt válasz).

# 5. scrape_series_added
Ez az érték azt mutatja, hogy hány új idősort (time series-t) adott hozzá a Prometheus a tárolójához a scrape során.
Ha 0 -> vagy nem volt új adat, vagy nem sikerült elérni a célt.

# Ezek honnan származnak?
Ezek automatikusan generált mutatók, amiket a Prometheus saját maga hoz létre minden célhoz, nem a cél szolgáltatásai küldik vissza!
Ezek alapján tudod ellenőrizni például:
  Melyik szolgáltatás elérhető?
  Melyik mikor omlott le?
  A scrape műveletek gyorsak vagy lassúak?
  Mennyire stabil a monitorozott rendszer?

# Mit tehetsz velük?
Gyakorlati példa:

1. Alert (riasztás) létrehozása:

up == 0

Ha egy cél DOWN, erről tudsz alert-et küldeni e-mailen, Slacken, stb. pl. Alertmanagerrel.

2. Grafikon a scrape időkről:

avg_over_time(scrape_duration_seconds[1m])

Ez megmutatja, ha pl. egy szolgáltatás lassan válaszol – hasznos teljesítménydiagnosztikához.

# 3. Hibás scrape-ek figyelése:

increase(scrape_samples_scraped[5m]) == 0

Ha egy cél 5 percen belül semmit nem adott vissza, az is intő jel.

Összefoglalás – up és barátai
Metrika					Mit mutat
up					A cél elérhető-e (1 vagy 0)
scrape_duration_seconds			Lekérés ideje
scrape_samples_scraped			Hány minta jött
scrape_samples_post_metric_relabeling	Minta relabeling után
scrape_series_added			Hány új sor került be

Ezek mindig jelen vannak minden scrape_configs-ban szereplő target esetén – még akkor is, ha maga a cél nem ad vissza metrikát!

# Mik azok a hisztogramok a Prometheusban?---------------------------------------------------------
A hisztogram egy metrikatípus, amely megmutatja, hogy egy érték milyen
eloszlás szerint jelenik meg egy adott időszak alatt.
Tipikusan válaszidők, kérésidők, feldolgozási idők mérésére használják.

A hisztogram három fő részből áll:
1. *_bucket – hány darab esemény esett egy adott idő alá (küszöb, le = less than or equal).
2. *_sum – az összes érték összege (pl. összes válaszidő).
3. *_count – összesen hány esemény történt.

Miért hasznos a hisztogram?
Mert nemcsak az átlagot tudjuk nézni, hanem a eloszlást is. Például:
  Mennyire gyakoriak a lassú válaszok?
  A kérések hány százaléka esik 100ms alá?
  Mennyi a 90. percentilis (p90) válaszidő – vagyis az az érték, amelynél a kérések 90%-a gyorsabb volt?
Ez a fajta elemzés kulcsfontosságú például SLA-k, felhasználói élmény és rendszerhangolás szempontjából.

Hogyan jelennek meg ezek az adatok?
Vegyük ezt az egyszerű példát:
⬆ count ➡ duration(ms)

request_duration_seconds_bucket{le="0.025"} 31
request_duration_seconds_bucket{le="0.05"} 63
request_duration_seconds_bucket{le="0.1"} 168
request_duration_seconds_bucket{le="0.25"} 785
request_duration_seconds_bucket{le="+Inf"} 1000

request_duration_seconds_sum 180.43
request_duration_seconds_count 1000

Ez azt jelenti:
  31 kérés volt 25ms alatt
  63 kérés volt 50ms alatt
  ...
  összesen 1000 kérés történt
  ezek összesített válaszideje 180.43 másodperc volt
A bucketek halmozottak (azaz a le="0.1" tartalmazza a le="0.05" és le="0.025" értékeit is).

Hogyan lehet lekérdezni őket PromQL-ben?
histogram_quantile(φ, rate(...))
Ez a kulcs! A Prometheus nem számol quantile-okat automatikusan –
de a histogram_quantile() függvény segítségével becsülheted őket. Példák:

90. percentilis válaszidő:

histogram_quantile(0.9, rate(request_duration_seconds_bucket[5m]))

Ez azt jelzi, hogy az elmúlt 5 percben a kérések 90%-a milyen válaszidő alatt teljesült.

Egyesítve több dimenzió mentén (pl. status, method, path):

histogram_quantile(0.9, sum by(le) (rate(request_duration_seconds_bucket[5m])))

Konkrét útvonalra:

demo_api_request_duration_seconds_bucket{instance="demo-service-0:10000",status="500",method="POST",path="/api/foo"}

Ezzel szűrsz egy adott API endpoint-ra és hibakódra.

Átlagos válaszidő számítása
Ez kicsit trükkös, de az alábbi képlet segít:

rate(demo_api_request_duration_seconds_sum[5m])
/
rate(demo_api_request_duration_seconds_count[5m])

Ez lényegében az átlagos válaszidő az elmúlt 5 percben.

Megjegyzések:
  A rate() mindig időablakon belüli mértékeket ad (pl. 5 perc).
  A increase() inkább akkor hasznos, ha szakaszok összegét szeretnéd látni.
  A hisztogramok akkor igazán hasznosak, ha jó bin-kiosztást választasz (le értékek).
  A +Inf bucket minden eseményt tartalmaz, tehát ugyanannyit mutat, mint a *_count.

Összegzés:
Fogalom					Jelentés
*_bucket{le="0.1"}			Azon események száma, melyek legfeljebb 0.1s hosszúak voltak
*_sum					Az események összesített értéke
*_count					Az események száma
histogram_quantile(0.9, rate(...))	Becslés a 90. percentilisre
rate(sum / count)			Átlag érték egy időablakra

# Grafana Dashboard készítés Prometheus adatokhoz-----------------------------------------------------
Grafana telepítése

1. Dockerrel (ajánlott teszteléshez)

docker run -d -p 3000:3000 --name=grafana -v grafana-storage:/var/lib/grafana grafana/grafana

2. Letöltés bináris fájlként (Linux)
  Nyisd meg: grafana.com/download
  Válaszd:
    Edition: OSS → Linux → Download .tar.gz

mkdir grafana && cd grafana
wget https://dl.grafana.com/oss/release/grafana-12.0.0.linux-amd64.tar.gz
tar -zxvf grafana-12.0.0.linux-amd64.tar.gz
cd grafana-12.0.0/
./bin/grafana-server

A conf/ könyvtárban található a konfiguráció (alapértelmezett port: 3000)
A bin/ könyvtárban a futtatható szerverfájl

Grafana használata böngészőből
Cím: http://localhost:3000 vagy http://<szerver_ip>:3000

Belépés:
Felhasználó: admin
Jelszó: admin

Első belépésnél átugorható a jelszócsere (demo/lab esetén)

Prometheus adatforrás hozzáadása
  Configuration -> Data sources -> Add data source
  Válaszd ki a Prometheus-t
  Állítsd be:
    Name: Demo Prometheus
    URL: http://localhost:9090 vagy http://<szerver_ip>:9090
  Alul: Save & test

Új dashboard létrehozása
1. Panel hozzáadása
  Dashboard -> New Dashboard -> Add visualization
  Visualization típusa: pl. Time series
  Jobb oldalt 3 fül:
    Visualization
    Data -> Queries
    Panel options

Példa: 95. percentilis válaszidő lekérdezése
Data Queries fül:
  Metrika: demo_api_request_duration_seconds_bucket
  Kattints: hint: add histogram_quantile()
Hagyjuk a rate intervallumot: rate(...)
sum by(le, path, method)
Állítsuk a Quantile értékét: 0.95
Nyomj Run queries-t

Kód nézet (jobb fent "Code" gomb):

histogram_quantile(0.95, sum by(le, path, method) (rate(demo_api_request_duration_seconds_bucket[$__rate_interval])))

Legend: Custom -> {{path}} {{method}}
Panel options:
  Title: 95th Percentile Request Latency
  Unit: Time -> seconds

Példa: CPU-használat Gauge panel
  Visualization: Gauge
  Query (Code nézet):

sum by(instance) (rate(demo_cpu_usage_seconds_total{mode!="idle"}[5m]))
/
on(instance) group_left() demo_num_cpus

Panel Options:
  Min: 0
  Max: 1
  Unit: Percent (0.0 – 1.0)
  Threshold: Red at 0.8
  Title: Instance CPU Usage

Példa: Top 3 legnagyobb lekérés gyakoriság (Table panel)
  Visualization: Table
  Query (Code):

topk(3, sum by(path, method) (rate(demo_api_request_duration_seconds_count[5m])))

Panel Options:
  Format: Table
  Legend: pl. {method="POST", path="/api/foo"}
  Transform -> Organize fields -> rejt el felesleges mezőket (pl. Time)
  Field override: Unit = req/sec (rps)
  Title: Top 3 Request Rates

Sorok és szekciók hozzáadása
  Add new row -> Add panelt húzd be a sorba
  Row beállítások (fogaskerék):
    Cím: pl. HTTP Status vagy CPS Status
  Panelek átrendezhetők, összecsukhatók

Mentés:
  Jobb felső sarok → Save dashboard
  Adj nevet a dashboardnak
  Készen is vagy!



folyt köv....
